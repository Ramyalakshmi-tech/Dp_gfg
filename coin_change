https://www.geeksforgeeks.org/problems/coin-change2448/1


class Solution {
    public int count(int coins[], int sum) {
        int[][] dp = new int[sum + 1][coins.length+1];
        for (int[] row : dp) {
            Arrays.fill(row, -1);
        }
       // coinRecur(coins,sum,coin,0,0);
        return coinMemo(coins, sum, 0, dp);
       // return coinTab(coins,sum);
    }
    
    public int coinTab(int[] coins, int sum) {
        int n = coins.length;
        int[][] dp = new int[sum + 1][n + 1];

        // Base case: One way to make sum = 0 (by taking no coins)
        for (int j = 0; j <= n; j++) {
            dp[0][j] = 1;
        }

        // Fill the DP table
        for (int i = 1; i <= sum; i++) {  // Iterate over possible sums
            for (int j = 1; j <= n; j++) {  // Iterate over available coins
                dp[i][j] = dp[i][j - 1]; // Exclude current coin
                if (i >= coins[j - 1]) {
                    dp[i][j] += dp[i - coins[j - 1]][j]; // Include current coin
                }
            }
        }

        return dp[sum][n];
     }
    public int coinMemo(int[] coins, int sum, int ind, int[][] dp) {
        if (sum == 0) return 1;  // Found one valid way
        if (sum < 0 || ind >= coins.length) return 0; // No valid way

        if (dp[sum][ind] != -1) return dp[sum][ind]; // Memoized result

        // Two choices:
        int include = coinRecur(coins, sum - coins[ind], ind, dp);  // Use this coin (again)
        int exclude = coinRecur(coins, sum, ind + 1, dp);  // Skip this coin

        return dp[sum][ind] = include + exclude;  // Store and return result
    }
    
    public void coinRecur(int[] coins,int sum,int[] nums,int currSum,int ind){
        if(currSum==sum){
            nums[0]++;
            return;
        }
        if(ind>=coins.length || currSum>sum) return;
        for(int i=ind;i<coins.length;i++){
            coinRecur(coins,sum,nums,currSum+coins[i],i);
        }
    }

}
